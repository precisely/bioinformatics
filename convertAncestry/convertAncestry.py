'''
convertAncestry: Python module for converting ancestry.com raw data to VCF format

Provided a ancestry.com data file as input, along with a
specially-formatted human genome sequence file and a human genome gene
coordinates file, this module will convert the data into a
Precise.ly-formatted VCF file. See the README for more information on
obtaining the human genome sequence and gene coordinate files.
'''


from pysam import VariantFile
import subprocess, sys, json, shutil, os
from time import time
from datetime import datetime
import tempfile
import gzip
import logging, traceback


def parse_ancestry_file(genotype_ancestry_path):
    '''Parse out the creation date and the genome assembly version
    from a Ancestry.com raw data file, and the number of SNPs, and return as a list.'''

    snp_counts = -1
    genome_verison = ''

    with open(genotype_ancestry_path) as file_ancestry:

        for line in file_ancestry:

            if line.startswith('#This file was generated by AncestryDNA at:'):
                timestamp_str = line.rstrip().split(': ')[1]
                datetime_object = datetime.strptime(timestamp_str, '%m/%d/%y %H:%M:%S %Z')

            if line.startswith('#of the SNP using human reference build'):
                genome_version = line.rstrip().split('build ')[1].split(' ')[0]

            if not line.startswith('#'):
                snp_counts += 1

    return [datetime_object, genome_version, snp_counts]


def augmented_vcf_file(vcf_file,
                           vcf_aug_file,
                           tmp_dir,
                           sample_id,
                           date_ancestry_process,
                           genome_version,
                           snp_count,
                           reference_file_name):
    '''
    This helper function writes out the parsed data into VCF format.
    '''

    vcf_in  = VariantFile(vcf_file)

    ## Add additional header lines to the VCF:

    new_header = vcf_in.header
    new_header.add_line('##fileDate='                  + datetime.strftime(datetime.now(), '%c')      )
    new_header.add_line('##AncestrySampleID='           + sample_id                                    )
    new_header.add_line('##AncestryProcessDate='        + datetime.strftime(date_ancestry_process, '%c'))
    new_header.add_line('##AncestryHumanGenomeVersion=' + genome_version                               )
    new_header.add_line('##AncestrySNPcount='           + str(snp_count)                               )
    new_header.add_line('##reference=file://'          + reference_file_name                          )
    #new_header.add_line('##FILTER=<ID=NOT_DETERMINED,Description="Genotype not determined by 23andMe">')


    temp_header_file = tmp_dir + '/header_temp.vcf'

    with open(temp_header_file, 'w') as header_file:

        logging.info('PySAM is buggy, returning an extra space character when printing the header object. Removing.')
        print >> header_file, new_header,

    # Do we want the old header to be included?
    with gzip.open(vcf_aug_file, 'w') as vcf_out:

        with open(temp_header_file, 'r') as header_file:
            for line in header_file:
                if line.startswith('#'):
                    print >> vcf_out, line.rstrip()


        with open(vcf_file, 'r') as vcf_in:

            for line in vcf_in:

                if not line.startswith('#') or line.startswith('rsid'):

                    fields = line.rstrip().split('\t')

                    ## Modify FILTER values
                    if fields[9] == '.':
                        fields[6] = 'NOT_DETERMINED'
                    else:
                        fields[6] = 'PASS'

                    print >> vcf_out, '\t'.join(fields)


    logging.info('Printed augmented VCF file to: ' + vcf_aug_file)
    return


def convert_ancestry_bcf(genotype_ancestry_path,
                            ref_human_genome_path,
                            annotate_file_path,
                            output_dir):
    '''
    Main function for converting 23andMe raw data file into a VCF
    file. Returns a string path to the output file location.
    '''

    ## Definitions:
    [sample_id, file_md5_hash_value] = genotype_ancestry_path.split('/')[-1].split('_')

    tmp_dir = tempfile.mkdtemp()

    logging.info("Working directory is : " + tmp_dir)

    temp_vcf_file     = tmp_dir + '/' + sample_id + '_temp.vcf'

    vcf_aug_file = tmp_dir + '/' + sample_id + '.vcf.gz'

    ## Command for using bcftools for converting 23&Me tab-delimited
    ## genotype files to VCF format:

    # subprocess.check_output([
    #     'bcftools',
    #     'convert',
    #     '--tsv2vcf',
    #     genotype_ancestry_path,
    #     '-f',
    #     ref_human_genome_path,
    #     '-s',
    #     sample_id,
    #     '-Ob',
    #     '-o',
    #     temp_bcf_file])

    ## Get 23andMe raw file stats:
    [ processing_datetime,
          genome_version,
          snp_count        ] = parse_23andMe_file(genotype_ancestry_path)


    ## Make header file

    with open(tmp_dir + '/header-file.txt','w') as header_file:
        print >> header_file, "##INFO=<ID=GENE,Number=1,Type=String,Description=\"Gene name from UCSC Genome Browser BED file\">"

    subprocess.check_output(' '.join(['bcftools',
                                        'convert',
                                        '--tsv2vcf',
                                        genotype_ancestry_path,
                                        '-f',
                                        ref_human_genome_path,
                                        '-s',
                                        sample_id,
                                        '-Ob',
                                        '|',
                                        'bcftools',
                                        'annotate',
                                        '-a',
                                        annotate_file_path,
                                        '-c CHROM,FROM,TO,GENE',
                                        '-h',
                                        tmp_dir + '/header-file.txt',
                                        '-Ov',
                                        '-o',
                                        temp_vcf_file,
                                        '-']),
                                shell=True)



    augmented_vcf_file(temp_vcf_file,
                           vcf_aug_file,
                           tmp_dir,
                           sample_id,
                           processing_datetime,
                           genome_version,
                           snp_count,
                           ref_human_genome_path)

    vcf_aug_base_file_name = sample_id + '.vcf.gz'

    logging.info('Trying to remove same file from output directory, if it is already there from a previous run.')
    try:
        os.remove(output_dir + '/' + vcf_aug_base_file_name)
    except OSError:
        pass

    logging.info('Moving output from temp directory to output directory.')
    shutil.move(vcf_aug_file, output_dir)
    logging.info('Deleting temp directory.')
    shutil.rmtree(tmp_dir)

    print output_dir + '/' + vcf_aug_base_file_name
    return output_dir + '/' + vcf_aug_base_file_name



## Obtain variable definitions from the environment:
if __name__ == "__main__":

    genotype_ancestry_path = sys.argv[1]
    ref_human_genome_path = sys.argv[2]
    annotate_file_path    = sys.argv[3]
    output_dir            = sys.argv[4]

    try:

        convert_ancestry_bcf(genotype_ancestry_path,
                                ref_human_genome_path,
                                annotate_file_path,
                                output_dir)

    except:
        ## Trap any errors when running as script, and report the
        ## stack trace:
        [sample_id, file_md5_hash_value] = genotype_ancestry_path.split('/')[-1].split('_')

        error_file_path = output_dir + '/' + sample_id + '.error'

        with open(error_file_path, 'w') as error_file:

            print >> error_file, "Exception type:", sys.exc_info()[0]
            print >> error_file, "Exception Args:", sys.exc_info()[1]
            print >> error_file, traceback.format_exc()

        print error_file_path
        sys.exit(1)
