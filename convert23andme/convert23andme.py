'''
convert23andme: Python module for converting 23andMe raw data to VCF format

Provided a 23andMe data file as input, along with a
specially-formatted human genome sequence file and a human genome gene
coordinates file, this module will convert the data into a
Precise.ly-formatted VCF file. See the README for more information on
obtaining the human genome sequence and gene coordinate files.

TODOs:
* In a future version, we need to dispatch on file metadata to
  automagically select the correct version of the reference genome.
  See get_genome_version for where the logic needs to be inserted,
  and definition of cruzdb.
'''


### Import statements:
from pysam import VariantFile
import subprocess, sys, json, shutil, os
from time import time
from datetime import datetime
import tempfile
import gzip
import logging, traceback


### Global Definitions:

## Hash that maps genome version and chromosome ID to NCBI Accession number:
human_genome_accessions = {
    '37': {
        '1':  'NC_000001.10',
        '2':  'NC_000002.11',
        '3':  'NC_000003.11',
        '4':  'NC_000004.11',
        '5':  'NC_000005.9',
        '6':  'NC_000006.11',
        '7':  'NC_000007.13',
        '8':  'NC_000008.10',
        '9':  'NC_000009.11',
        '10': 'NC_000010.10',
        '11': 'NC_000011.9',
        '12': 'NC_000012.11',
        '13': 'NC_000013.10',
        '14': 'NC_000014.8',
        '15': 'NC_000015.9',
        '16': 'NC_000016.9',
        '17': 'NC_000017.10',
        '18': 'NC_000018.9',
        '19': 'NC_000019.9',
        '20': 'NC_000020.10',
        '21': 'NC_000021.8',
        '22': 'NC_000022.10',
        'X':  'NC_000023.10',
        'Y':  'NC_000024.9',
        'MT': 'NC_012920.1'
        }
    }

    
def parse_23andMe_file(genotype_23andme_path):
    '''Parse out the creation date and the genome assembly version
    from a 23andMe raw data file, and the number of SNPs, and return as a list.'''

    snp_counts = 0
    genome_verison = ''
    
    with open(genotype_23andme_path) as file_23andMe:

        for line in file_23andMe:

            if line.startswith('# This data file generated by 23andMe at:'):
                timestamp_str = line.rstrip().split(': ')[1]
                datetime_object = datetime.strptime(timestamp_str, '%c')
            
            if line.startswith('# More information on reference human assembly build'):
                genome_version = line.rstrip().split('build ')[1].split(' ')[0]
            
            if not line.startswith('#'):
                snp_counts += 1                
                
    return [datetime_object, genome_version, snp_counts]



## Turns out that chip processing times overlap the stated chip release periods listed at:
## https://isogg.org/wiki/23andMe#Chip_versions
## So, indicator SNP IDs is probably the only reliable way to identify which chip was used,
## and that will require much more work to compute.

def predict_23andMe_chip_version(datetime_object, snp_counts):
'''
Try to predict the 23andMe chip version used to generate the 23andMe
raw data file. Experimental.
'''
    version = ''
    
    if datetime_object < datetime(2007,11,1):
        version = 'invalid-date'

    elif datetime_object >= datetime(2007,11,1) and datetime_object < datetime(2008,9,1):
        version = 'v1'

    elif datetime_object >= datetime(2008,9,1) and datetime_object < datetime(2010,11,1) and snp_counts > 547000 and snp_counts < 562000:

        version = 'v2'
        
    elif datetime_object >= datetime(2010,11,1) and datetime_object < datetime(2013,11,1) and snp_counts > 900000:

        version = 'v3'

    elif datetime_object >= datetime(2013,11,1) and datetime_object < datetime(2017,8,1) and snp_counts > 563000 and snp_counts < 577000:

        version = 'v4'

    elif datetime_object >= datetime(2017,8,1) and snp_counts > 633000 and snp_counts < 647000:   
        
        version = 'v4'

    else:
        version = 'undefined'

    return version







def convert_23andme_bcf(genotype_23andme_path,
                            ref_human_genome_path,
                            annotate_file_path,
                            output_dir):
'''
Main function for converting 23andMe raw data file into a VCF
file. Returns a string path to the output file location.
'''
    
    ## Definitions:    
    [sample_id, file_md5_hash_value] = genotype_23andme_path.split('/')[-1].split('_')

    tmp_dir = tempfile.mkdtemp()

    logging.info("Working directory is : " + tmp_dir)
    
    temp_vcf_file     = tmp_dir + '/' + sample_id + '_temp.vcf'

    vcf_aug_file = tmp_dir + '/' + sample_id + '.vcf.gz'
    
    ## Command for using bcftools for converting 23&Me tab-delimited
    ## genotype files to VCF format:
    
    # subprocess.check_output([
    #     'bcftools',
    #     'convert',
    #     '--tsv2vcf',
    #     genotype_23andme_path,
    #     '-f',
    #     ref_human_genome_path,
    #     '-s',
    #     sample_id,
    #     '-Ob',
    #     '-o',
    #     temp_bcf_file])

    ## Get 23andMe raw file stats:
    [ processing_datetime,
          genome_version,
          snp_count        ] = parse_23andMe_file(genotype_23andme_path)

    
    ## Make header file
    
    with open(tmp_dir + '/header-file.txt','w') as header_file:
        print >> header_file, "##INFO=<ID=GENE,Number=1,Type=String,Description=\"Gene name from UCSC Genome Browser BED file\">"
        
    subprocess.check_output(' '.join(['bcftools',
                                        'convert',
                                        '--tsv2vcf',
                                        genotype_23andme_path,
                                        '-f',
                                        ref_human_genome_path,
                                        '-s',
                                        sample_id,
                                        '-Ob',
                                        '|',
                                        'bcftools',
                                        'annotate',
                                        '-a',
                                        annotate_file_path,
                                        '-c CHROM,FROM,TO,GENE',
                                        '-h',
                                        tmp_dir + '/header-file.txt',
                                        '-Ov',
                                        '-o',
                                        temp_vcf_file,
                                        '-']),
                                shell=True)


    
    augmented_vcf_file(temp_vcf_file,
                           vcf_aug_file,
                           tmp_dir,
                           sample_id,
                           processing_datetime,
                           genome_version,
                           snp_count,
                           ref_human_genome_path)

    vcf_aug_base_file_name = sample_id + '.vcf.gz'
    
    logging.info('Trying to remove same file from output directory, if it is already there from a previous run.')
    try:
        os.remove(output_dir + '/' + vcf_aug_base_file_name)
    except OSError:
        pass

    logging.info('Moving output from temp directory to output directory.')
    shutil.move(vcf_aug_file, output_dir)
    logging.info('Deleting temp directory.')
    shutil.rmtree(tmp_dir)

    print output_dir + '/' + vcf_aug_base_file_name
    return output_dir + '/' + vcf_aug_base_file_name


def augmented_vcf_file(vcf_file,
                           vcf_aug_file,
                           tmp_dir,
                           sample_id,
                           date_23andMe_process,
                           genome_version,
                           snp_count,
                           reference_file_name):
'''
This helper function writes out the parsed data into VCF format.
'''
    
    vcf_in  = VariantFile(vcf_file)

    ## Add additional header lines to the VCF:

    new_header = vcf_in.header
    new_header.add_line('##fileDate='                  + datetime.strftime(datetime.now(), '%c')      )
    new_header.add_line('##23andMeSampleID='           + sample_id                                    )
    new_header.add_line('##23andMeProcessDate='        + datetime.strftime(date_23andMe_process, '%c'))
    new_header.add_line('##23andMeHumanGenomeVersion=' + genome_version                               )
    new_header.add_line('##23andmeSNPcount='           + str(snp_count)                               )
    new_header.add_line('##reference=file://'          + reference_file_name                          )
    new_header.add_line('##INFO=<ID=GS,Number=1,Type=String,Description="Genotype Summary">')
    new_header.add_line('##INFO=<ID=HGVS,Number=1,Type=String,Description="Genotype in HGVS Sequence Variant Nomenclature format, with `~` instead of `=` and `///` instead of `;`">')
    new_header.add_line('##FILTER=<ID=NOT_DETERMINED,Description="Genotype not determined by 23andMe">')
    
    ##vcf_out = VariantFile(vcf_aug_file, 'w', header=new_header)

    temp_header_file = tmp_dir + '/header_temp.vcf'

    with open(temp_header_file, 'w') as header_file:
        
        logging.info('PySAM is buggy, returning an extra space character when printing the header object. Removing.')
        print >> header_file, new_header,
        
    
    with gzip.open(vcf_aug_file, 'w') as vcf_out:
    
        with open(temp_header_file, 'r') as header_file:                      
            for line in header_file:
                if line.startswith('#'):
                    print >> vcf_out, line.rstrip()   

                    
        with open(vcf_file, 'r') as vcf_in:

            for line in vcf_in:

                if not line.startswith('#'):
                
                    fields = line.rstrip().split('\t')

                    print >> vcf_out, augmented_vcf_record(vcf_out, fields, genome_version)


    logging.info('Printed augmented VCF file to: ' + vcf_aug_file)
    return

        
def augmented_vcf_record(out_file, fields, genome_version):

'''
This helper function generates a single VCF data record as a string.
'''
    
    hgvs_str = ''
    
    if fields[9] == '.':
        genotype_array = [None]
    else:
        genotype_array = map(int, fields[9].split('/'))
        
    genotype = gen_genotype_summary_str(genotype_array,fields[0])

    if genotype != 'not-determined':
        hgvs_str = gen_svn_genotype_string(genome_version,
                                            fields[0],
                                            fields[1],
                                            fields[3],
                                            fields[4],
                                            genotype)

        ## VCF format doesn't allow equals signs nor semi-colons in the values of INFO sub-fields,        
        ## so we substitute '~' for '=', and '///' for ';'
        hgvs_str = hgvs_str.replace('=','~').replace(';','///')
        
        info_str = 'GS=' + genotype + ';HGVS=' + hgvs_str

    else:
        info_str = 'GS=' + genotype

        
    ## Modify FILTER values
    if genotype == 'not-determined':
        fields[6] = 'NOT_DETERMINED'
    else:
        fields[6] = 'PASS'
    
    ## Modify INFO values
    if len(fields[7]) > 1:
        ##append
        fields[7] = fields[7] + ';' + info_str
    else:
        ##new
        fields[7] = info_str

    return '\t'.join(fields)
                
        
    
    
def print_vcf_to_ga4gh_json_file(vcf_file,json_out_file):
'''
This helper function prints the parsed data to GA4GH JSON
format. Deprecated.

'''
    ##json_out_file = ga4gh_out_dir + '/' + sample_id + '_ga4gh.json'

    variants      = []
    load_time     = time()
    i             = 0

    vcf_in        = VariantFile(vcf_file)
    
    with open(json_out_file,'w') as out_file:

        out_file.write('[')
        
        for rec in vcf_in:
            struct = gen_variant_call_struct(rec,
                                                 sample_id,
                                                 load_time)
            if struct != None:
                #variants.append(struct)
                out_file.write(json.dumps(struct, indent=4, separators=(',', ': ')))
                out_file.write(',')
           
        out_file.write(']')
                ##out_file.write(json.dumps(variants, indent=4, separators=(',', ': ')))

    print json_out_file


    
def gen_genotype_summary_str(genotype_array, chrom):
'''
This helper function return the genotype summary or zygosity token for
a given genotype_array and chromosome.
'''
    
    genotype = ''
    
    if genotype_array == [None]:
        genotype = 'not-determined'
        genotype_array = [-1, -1]
    elif genotype_array == [0, 0]:
        genotype = 'wildtype'
    elif genotype_array == [0, 1] or genotype_array == [1, 0]:
        genotype = 'heterozygous'
    elif genotype_array == [1, 1]:
        genotype = 'homozygous'
    elif genotype_array == [1, 2] or genotype_array == [2, 1]:
        genotype = 'compound-heterozygous'
    elif chrom in [ 'Y', 'MT', 'X' ] and genotype_array in [ [0], [1] ]:
        genotype = 'haploid'        
    else:
         print chrom, genotype_array
         raise Exception(chrom, genotype_array)

    return genotype


    
## Generate json stanza:
## If the variant is not within a gene, we discard it.
def gen_variant_call_struct(rec, sample_id, load_time):
'''
Helper function for generating a single JSON stanza. Deprecated.
'''
    
    genotype_array = list(rec.samples[sample_id].values()[0])

    genotype = gen_genotype_summary_str(genotype_array, rec.chrom)
    
    genome_version = get_genome_version()

    gene = ''
    if 'GENE' in rec.info:
        gene = rec.info['GENE']

    alt_bases = ''
    
    if rec.alts == None:
        alt_bases = '<NON_REF>'
    else:
        alt_bases = list(rec.alts)

    if genotype != 'not-determined':
        svn_str = gen_svn_genotype_string(get_genome_version(),
                                            rec.chrom,
                                            rec.pos,
                                            rec.ref,
                                            alt_bases,
                                            genotype)
        filter_val = 'PASS'
    else:
        svn_str = ''
        filter_val = 'NOT-DETERMINED'
    
    if gene == '':
        return None
    else:
        return {
            'alternateBases': alt_bases,
            'calls': [{
                'callSetId': sample_id,
                'genotype': genotype_array,
                'info': { 'FILTER': [ filter_val ] }
            }],
            'end': rec.stop,
            'referenceBases': rec.ref,
            'referenceName': 'chr' + rec.chrom,
            'start': rec.start,
            'attributes': {
                'sample': {
                    'load_time': load_time,
                    'reference_version': genome_version
                    },
                    'variant': {
                        'gene_symbols': gene,
                        'id': rec.id
                        },
                        'variant_call': {
                            'genotype': genotype,
                            'systematic_name': svn_str
                            }}}


    
    
## Generate a Sequence Variant Nomenclature-based description of the genotype:        
def gen_svn_genotype_string(genome_version,
                        chrom,
                        start,
                        ref,
                        alt_bases,
                        zygosity):
'''
Helper function for generating the HGVS (nee SVN) notation string for
the genotype. Returns the HGVS as a string.
'''
    
    accession = human_genome_accessions[genome_version][chrom]

    svn_str = accession + ':g.' 
    print_sub_template = '[{}{}>{}]'
    print_wildtype_template = '[{}=]'
    
    if zygosity == 'wildtype':
        svn_str = svn_str + \
          print_wildtype_template.format(start) + \
          ';' + \
          print_wildtype_template.format(start)
                                           
    elif len(alt_bases) == 1 and zygosity == 'heterozygous':
        svn_str = svn_str + \
          print_wildtype_template.format(start) + \
          ';' + \
          print_sub_template.format(start,
                                        ref,
                                        alt_bases[0])

    elif len(alt_bases) == 1 and zygosity == 'homozygous':
        svn_str = svn_str + \
          print_sub_template.format(start,
                                        ref,
                                        alt_bases[0]) + \
          ';' + \
          print_sub_template.format(start,
                                        ref,
                                        alt_bases[0])


    elif len(alt_bases) == 2:
        svn_str = svn_str + \
          print_sub_template.format(start,
                                        ref,
                                        alt_bases[0]) + \
          ';' + \
          print_sub_template.format(start,
                                        ref,
                                        alt_bases[1])

    elif zygosity == 'haploid' and alt_bases not in ['.', '<NON_REF>']:
        svn_str = svn_str + \
          print_sub_template.format(start,
                                        ref,
                                        alt_bases[0])

    elif zygosity == 'haploid' and alt_bases in ['.', '<NON_REF>']:
        svn_str = svn_str + \
          print_wildtype_template.format(start)

        
    return svn_str



## Obtain variable definitions from the environment:
if __name__ == "__main__":
    
    genotype_23andme_path = sys.argv[1]
    ref_human_genome_path = sys.argv[2]
    annotate_file_path    = sys.argv[3]
    output_dir            = sys.argv[4]

    try:
    
        convert_23andme_bcf(genotype_23andme_path,
                                ref_human_genome_path,
                                annotate_file_path,
                                output_dir)

    except:
        ## Trap any errors when running as script, and report the
        ## stack trace:
        [sample_id, file_md5_hash_value] = genotype_23andme_path.split('/')[-1].split('_')

        error_file_path = output_dir + '/' + sample_id + '.error'
        
        with open(error_file_path, 'w') as error_file:
            
            print >> error_file, "Exception type:", sys.exc_info()[0]
            print >> error_file, "Exception Args:", sys.exc_info()[1]
            print >> error_file, traceback.format_exc()

        print error_file_path
        sys.exit(1)
