from mamba import description, context, it
import convert23andme.convert23andme as andme
import convert_ancestry.convert_ancestry as ancestry
import sys
import random
import datetime as dt

_original_ancestry_file = 'convert_ancestry/mamba_out/AncestryDNA.txt'
_converted_23andme_file = 'convert_ancestry/mamba_out/converted_23andme.txt'

'''
Integration test for converting an Ancestry.com genotype file to
a 23andMe style file and finally to the VCF style.
To test an Ancestry.com raw data file, save it to:
bioinformatics/convert_ancestry/test/AncestryDNA.txt

Required files for 23andMe to VCF conversion:
bioinformatics/human_g1k_v37.fasta.gz
bioinformatics/convert23andme/ucsc-gene-symbols-coords.txt.gz

Required Directories:
bioinformatics/convertAncestry/test
'''


with description('Testing Ancestry.com to VCF conversion path') as testConverter:
    with context('Ancestry.com to 23andMe'):
        with it('takes in a Ancestry.com file stream and writes to an output stream'):
            in_stream = open(_original_ancestry_file, 'r')
            out_stream = open(_converted_23andme_file, 'w')
            ancestry.convert_ancestry(in_stream, out_stream)
            #assert File exists?


    with context('Converting 23andMe to VCF'):
        with it('has consistent data and metadata with the original Ancestry file'):
            vcf_file_path = andme.convert_23andme_bcf(_converted_23andme_file,
                                        'human_g1k_v37.fasta.gz',
                                        'convert23andme/ucsc-gene-symbols-coords.txt.gz',
                                        'convert_ancestry/mamba_out')    

            old_file = open(_original_ancestry_file, 'r')
            new_file = open(vcf_file_path, 'r')
            assert(check_conversion_accuracy(old_file, new_file))

#Helper functions for check_conversion_accuracy(original_file, converted_file)
def parse_vcf_metadata(line):
    '''
    Returns: metadata found on given line (if applicable) and is_datetime 
    if metadata is a datetime object. Returns None if no data is found.

    '''
    metadata = None
    is_datetime = False

    if line.startswith('##23andMeProcessDate='):
        is_datetime = True
        line.rstrip().split('= ')[1]
        try:
            metadata = dt.datetime.strptime(line, '%c')
        except(ValueError):
            raise ValueError('Bad input for VCF process date.')    

    elif line.startswith('##23andMeHumanGenomeVersion='):
        line.rstrip().split('= ')[1]
        metadata = line 
        try:
            float(metadata)
        except(ValueError):
            raise ValueError('Incorrect value for Human Genome version')    


    return [metadata, is_datetime] 


def parse_ancestry_metadata(line):
    '''
    Returns metadata found on line if applicable and True 
    if the data is a datetime object as a list. Raises 
    an error if input file is incorrectly formatted.
    '''
    metadata = None
    is_datetime = False
    if line.startswith('#This file was generated by AncestryDNA at:'):
        is_datetime = True
        timestamp_str = line.rstrip().split(': ')[1]
        try:
            metadata = dt.datetime.strptime(timestamp_str[:19], '%m/%d/%Y %H:%M:%S')
        except(ValueError):
            raise ValueError('Bad input for Ancestry file date.')     

    elif line.startswith('#of the SNP using human reference build'): 
        metadata = line.rstrip().split('build ')[1].split(' ')[0]
        try:
            float(metadata)
        except(ValueError):
            raise ValueError('Bad input for HRG version.')

    return [metadata, is_datetime]  

def is_snp_line(line):
    '''
    Checks if given line has SNP number
    '''
    return line.startswith('##23andmeSNPcount=')

def get_snp_count(line):
    '''
    Returns the number of SNPs in the file if given the 
    correct line.
    '''
    return line.rstrip.split('= ')[1]

def compare_metadata(ancestry, vcf):
    '''
    Given a stream of the Ancestry file and the converted VCF
    file, compares the metadata. Returns a tuple: 
    (boolean consistent, num_snps)
    The first element indicates if the metadata from both files is
    consistent. The second element is the number of data lines from
    the VCF file (used to decide which lines to compare in compare_data()).
    '''
    for line in ancestry:
        if line.startswith('rsid'):
            break

        [metadata, is_datetime] = parse_ancestry_metadata(line)
        if metadata and is_datetime:
            ancestry_date = metadata
            is_datetime = False
        elif metadata:
            ancestry_genome = metadata

    for line in vcf:
        if  line.startswith('##FILTER='):
            break

        if is_snp_line(line):
            num_snps = get_snp_count(line)
        
        [metadata, is_datetime] = parse_vcf_metadata(line)
        if metadata and is_datetime:
             vcf_date = metadata
             is_datetime = False
        elif metadata:
             vcf_genome = metadata
       
    if not vcf_genome == ancestry_genome:
        print('Human refrence genome numbers do not match')
        return (False, num_snps)
    if not vcf_date == ancestry_date:
        print('Dates of creation do not match')  
        return (False, num_snps)

    return (True, num_snps)    
    
def compare_data(ancestry, vcf, num_snps):
    '''
    Given streams for both files, determines if the data is equivalent
    by comparing a sample of entries from both files. returns True if 
    they all match, and False if they do not.
    '''
    compare_lines = randomize_sample_points(num_snps - 1)
    for i in range(num_snps):
        ancestry_line = next(ancestry)
        vcf_line = next(vcf)
        if i in compare_lines:
            check_line(ancestry_line, vcf_line)

    return True

def randomize_sample_points(num_snps):
    '''
    Given the number of SNPs in the files, generates 10 random numbers
    within the range (0:num_snps) to be extracted and compared to it's
    opposite filetype counterpart. 
    '''
    random_nums = []
    for x in range(10):
        random_nums.append(random.randint(1, num_snps))

    return random_nums     

def check_line(line_ancestry, line_vcf):
    '''
    Given a data line from the Ancestry file and its VCF
    counterpart from the converted file, decides if the
    values match up. Returns True if they match, False and 
    prints the Ancestry rsid of the SNP if they don't match
    '''
    ancestry_fields = line_ancestry.rstrip().split('\t')
    ancestry_fields[3] = ancestry_fields[3] + ancestry_fields[4]
    vcf_fields = line_vcf.rstrip().split('\t')
    
    for i in range(3):
        if ancestry_fields[i] != vcf_fields[i]:
            print("Files inconsistent: SNP number: " + ancestry_fields[0])
            return False
    return True

# Main testing method
def check_conversion_accuracy(file_original, file_new):
    '''
    Main method for testing the conversion pathway. Randomly compares 
    ten lines from the original file to the new file given a 
    stream of the original Ancestry file and a stream of the 
    newly generated VCF. Also ensures that metadata is 
    consistent between files. Returns True if files are 
    consistent. Returns an error if any inconsistencies 
    between the original and new VCF file are found.
    (metadata refers to the date of creation and HRG number)
    '''     
    
    (metadata_matches, num_snps) = compare_metadata(file_original, file_new)
    data_matches = compare_data(file_original, file_new, num_snps)

    if metadata_matches and data_matches:
        return True
    else:
        return False    
    
