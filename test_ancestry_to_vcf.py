from mamba import description, context, it
import convert_ancestry.convert_ancestry as ancestry
import convert23andme.convert23andme as andme
import sys
import random
import datetime

'''
Integration test for converting an Ancestry.com genotype file to
a 23andMe style file and finally to the VCF style.
To test an Ancestry.com raw data file, save it to:
bioinformatics/convert_ancestry/test/AncestryDNA.txt

Required files for 23andMe to VCF conversion:
bioinformatics/human_g1k_v37.fasta.gz
bioinformatics/convert23andme/ucsc-gene-symbols-coords.txt.gz

Required Directories:
bioinformatics/convertAncestry/test
'''


with description('Testing Ancestry.com to VCF conversion path') as testConverter:

    with it('Converting Ancestry to 23andMe'):
        with context('Creating Generators'):
            in_stream = ancestry.input_file_generator('convert_ancestry/test/AncestryDNA.txt')
            out_stream = ancestry.output_file_generator('convert_ancestry/test/converted23andme.txt')
        
        #with context('Calling convert_ancestry()'):
            converted_23andme_file = ancestry.convert_ancestry(in_stream, out_stream)
        
        with context('Checking accuracy converted 23andMe file'):
            old_file = ancestry.input_file_generator('convert_ancestry/test/AncestryDNA.txt')
            new_file = ancestry.input_file_generator('convert_ancestry/test/converted23andme.txt')
            assert(check_conversion_accuracy(old_file, new_file))


    with it('Converting 23andMe to VCF'):
        with context('Calling convert_23andme_bcf()'):
            vcf_file = andme.convert_23andme_bcf('convert_ancestry/test/converted23andme.txt',
                                        'human_g1k_v37.fasta.gz',
                                        'convert23andme/ucsc-gene-symbols-coords.txt.gz',
                                        'convert_ancestry/test')    

        with context('Checking accuracy converted VCF file'):
            old_file = ancestry.input_file_generator('convert_ancestry/test/converted23andme.txt')
            new_file = ancestry.input_file_generator(vcf_file)
            assert(check_conversion_accuracy(old_file, new_file))

def parse_vcf_metadata(line):
    '''
    Returns metadata found on line if applicable and True 
    if metadata is a datetime object as a list. Returns None 
    if no data is found.

    '''
    metadata = None
    is_datetime = False

    if line.startswith('##23andMeProcessDate='):
        is_datetime = True
        line.rstrip().split('= ')[1]
        metadata = datetime.strptime(line, '%c')

    elif line.startswith('##23andMeHumanGenomeVersion='):
        line.rstrip().split('= ')[1]
        metadata = line 


    return [metadata, is_datetime] 


def parse_ancestry_metadata(line):
    '''
    Returns metadata found on line if applicable and True 
    if the data is a datetime object as a list. Raises 
    an error if input file is incorrectly formatted.
    '''
    metadata = None
    is_datetime = False
    if line.startswith('#This file was generated by AncestryDNA at:'):
        is_datetime = True
        timestamp_str = line.rstrip().split(': ')[1]
        try:
            metadata = datetime.strptime(timestamp_str[:19], '%m/%d/%Y %H:%M:%S')
        except(ValueError):
            raise ValueError('Bad input for Ancestry file date.')     

    elif line.startswith('#of the SNP using human reference build'): 
        metadata = line.rstrip().split('build ')[1].split(' ')[0]
        try:
            float(metadata)
        except(ValueError):
            raise ValueError('Bad input for HRG version.')

    return [metadata, is_datetime]  

def is_snp_line(line):
    '''
    Checks if given line has SNP number
    '''
    return line.startswith('##23andmeSNPcount=')

def get_snp_count(line):
    '''
    Returns the number of SNPs in the file if given the 
    correct line.
    '''
    return line.rstrip.split('= ')[1]

def compare(line_ancestry, line_vcf):
    '''
    Given two data lines, determines if the lines are equivalent.
    returns True if so, False if not.
    '''
    ancestry_fields = line_ancestry.rstrip().split('\t')
    ancestry_fields[3] = ancestry_fields[3] + ancestry_fields[4]
    vcf_fields = line_vcf.rstrip().split('\t')
    
    for i in range(3):
        if ancestry_fields[i] != vcf_fields[i]:
            return False
    return True        

def compare_random_lines(file_orig, file_new, num_snps):
    '''
    Given two streams this method will grab and compare 10 pairs 
    of lines that should match between the original file and the 
    converted VCF file. Assumes that the file streams have already
    passed the headers.
    '''
    random_nums = []
    for x in range(10):
        random_nums.append(random.randint(1, num_snps))

    for i in range(num_snps):
        line_orig = file_orig.next()
        line_new = file_new.next()
        if i in random_nums:
            random_nums.remove(i)
            if not compare(line_orig, line_new):
                print('Data line' + i + 'does not match')
                return False

    return True            

def check_conversion_accuracy(file_original, file_new):
    '''
    Main method for testing the conversion pathway. Randomly compares 
    ten lines from the original file to the new file given a 
    stream of the original Ancestry file and a stream of the 
    newly generated VCF. Also ensures that metadata is 
    consistent between files. Returns True if files are 
    consistent. Returns an error if any inconsistencies 
    between the original and new VCF file are found.
    (metadata refers to the date of creation and HRG number)
    '''     
    vcf_date = None
    vcf_genome = None
    ancestry_date = None
    ancestry_genome = None
    num_snps = None

    #metadata
    for line in file_original:
        if not line.startswith('#') or not line.startswith('rsid'):
            break

        [metadata, is_datetime] = parse_ancestry_metadata(line)
        if metadata and is_datetime:
            ancestry_date = metadata
        elif metadata:
            ancestry_genome = metadata
    #data
    for line in file_new:
        if is_snp_line(line):
            num_snps = get_snp_count(line)
        if not line.startswith('#'):
            break
        [metadata, is_datetime] = parse_vcf_metadata(line)
        if metadata and is_datetime:
             vcf_date = metadata
        elif metadata:
             vcf_genome = metadata
       
    if not vcf_genome == ancestry_genome:
        print('Human refrence genome numbers do not match')
        return False 
    if not vcf_date == ancestry_date:
        print('Dates of creation do not match')  
        return False  

    return compare_random_lines(file_original, file_new, num_snps)
